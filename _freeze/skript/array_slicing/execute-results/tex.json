{
  "hash": "2e8a723e072dbd41029a9a1f75012551",
  "result": {
    "engine": "jupyter",
    "markdown": "# Slicing\n\n\n\n## Normales Slicing mit Zahlenwerten\n\n![Ansprechen der einzelnen Achsen für den ein-, zwei- und dreidimensionallen Fall inkl. jeweiligem Beispiel](../skript/00-bilder/slicing.png){#fig-slicing fig-alt=\"AUswahl der jeweiligen Achsen für NumPy Arrays von verschiedener Dimension, dargestellt durch gestapelte Blöcke\"}\n\nMöchte man jetzt Daten innerhalb eines Arrays auswählen so geschieht das in der \nForm:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nliste = np.array([1, 2, 3, 4, 5, 6])\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Auswählen des ersten Elements\nliste[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nnp.int64(1)\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Auswählen des letzen Elements\nliste[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nnp.int64(6)\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Auswählen einer Reihe von Elementen\nliste[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([2, 3, 4])\n```\n:::\n:::\n\n\nFür zwei-dimensionale Arrays wählt man getrennt durch ein Komma mit einer \nzweiten Zahl die zweite Dimension aus.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Auswählen einer Elements\nmatrix[1,1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nnp.int64(5)\n```\n:::\n:::\n\n\nFür drei-dimensionale Arrays wählt man getrennt durch ein Komma mit einer \nweiteren Zahl die dritte Dimension aus. Dabei wird dieses jedoch an die erste \nStelle gesetzt. \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nmatrix_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(matrix_3d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 1  2  3]\n  [ 4  5  6]]\n\n [[ 7  8  9]\n  [10 11 12]]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Auswählen eines Elements\nmatrix_3d[1,0,2]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nnp.int64(9)\n```\n:::\n:::\n\n\n## Slicing mit logischen Werten (Boolesche Masken)\n\nBeim logischen Slicing wird eine boolesche Maske verwendet, um bestimmte Elemente \neines Arrays auszuwählen. Die Maske ist ein Array gleicher Länge wie das Original, \ndas aus `True` oder `False` Werten besteht. \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Erstellen wir ein Beispiel Array\na = np.array([1, 2, 3, 4, 5, 6])\n\n# Erstellen der Maske\nmaske = a > 3\n\nprint(maske)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[False False False  True  True  True]\n```\n:::\n:::\n\n\nWir erhalten also ein Array mit boolschen Werten. Verwenden wir diese Maske nun\nzum slicen, erhalten wir alle Werte an den Stellen, an denen die Maske den Wert \n`True` besitzt.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Anwenden der Maske\nprint(a[maske])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4 5 6]\n```\n:::\n:::\n\n\n::: {.callout-warning}\n\nDas Verwenden von booleschen Arrays ist nur im numpy-Modul möglich. Es ist nicht\nMöglich dieses Vorgehen auf native Python Listen anzuwenden. Hier muss durch die \nListe iterriert werden.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5, 6]\nergebniss = [x for x in a if x > 3]\nprint(ergebniss) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4, 5, 6]\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n\n## Zwischenübung: Array-Slicing\n\nWählen Sie die farblich markierten Bereiche aus dem Array \"matrix\" mit den eben \ngelernten Möglichkeiten des Array-Slicing aus.\n\n![](../skript/00-bilder/exercise_slicing.svg)\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nmatrix = np.array([\n    [2, 11, 18, 47, 33, 48, 9, 31, 8, 41],\n    [55, 1, 8, 3, 91, 56, 17, 54, 23, 12],\n    [19, 99, 56, 72, 6, 13, 34, 16, 77, 56],\n    [37, 75, 67, 5, 46, 98, 57, 19, 14, 7],\n    [4, 57, 32, 78, 56, 12, 43, 61, 3, 88],\n    [96, 16, 92, 18, 50, 90, 35, 15, 36, 97],\n    [75, 4, 38, 53, 1, 79, 56, 73, 45, 56],\n    [15, 76, 11, 93, 87, 8, 2, 58, 86, 94],\n    [51, 14, 60, 57, 74, 42, 59, 71, 88, 52],\n    [49, 6, 43, 39, 17, 18, 95, 6, 44, 75]\n])\n```\n:::\n\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Lösung\n\n* Rot: matrix[1,3]\n* Grün: matrix[4:6,2:6]\n* Pink: matrix[:,7]\n* Orange: matrix[7,:5]\n* Blau: matrix[-1,-1]\n\n:::\n\n:::\n\n",
    "supporting": [
      "array_slicing_files/figure-pdf"
    ],
    "filters": []
  }
}
{
  "hash": "3d01de43dd95d535f0aceae6286617b2",
  "result": {
    "engine": "jupyter",
    "markdown": "# Slicing\n\n\n\n## Normales Slicing mit Zahlenwerten\n\n![Ansprechen der einzelnen Achsen für den ein-, zwei- und dreidimensionallen Fall inkl. jeweiligem Beispiel](../skript/00-bilder/slicing.png){#fig-slicing fig-alt=\"Auswahl der jeweiligen Achsen für NumPy-Arrays von verschiedener Dimension, dargestellt durch gestapelte Blöcke.\"}\n\nMöchte man Daten innerhalb eines Arrays auswählen, so geschieht das in der \nForm:\n\n1. `array[a]` wobei ein einzelner Wert an Position a ausgegeben wird.\n2. `array[a:b]` wobei alle Werte von Position a bis Position b-1 ausgegeben werden.\n3. `array[a:b:c]` wobei die Werte von Position a bis Position b-1 mit einer Schrittweite von c ausgegeben werden.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nliste = np.array([1, 2, 3, 4, 5, 6])\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Auswählen des ersten Elements\nliste[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nnp.int64(1)\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Auswählen des letzten Elements\nliste[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nnp.int64(6)\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Auswählen einer Reihe von Elementen\nliste[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([2, 3, 4])\n```\n:::\n:::\n\n\nFür zweidimensionale Arrays wählt man mit einer zweiten, durch ein Komma von der ersten getrennten Zahl die zweite Dimension aus.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Auswählen eines Elements\nmatrix[1,1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nnp.int64(5)\n```\n:::\n:::\n\n\nFür dreidimensionale Arrays wählt man mit einer weiteren, ebenfalls durch ein Komma getrennten Zahl die dritte Dimension aus. Dabei wird diese jedoch an die erste Stelle gesetzt. \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nmatrix_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(matrix_3d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 1  2  3]\n  [ 4  5  6]]\n\n [[ 7  8  9]\n  [10 11 12]]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Auswählen eines Elements\nmatrix_3d[1,0,2]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nnp.int64(9)\n```\n:::\n:::\n\n\n## Slicing mit logischen Werten (boolesche Masken)\n\nBeim logischen Slicing wird eine boolesche Maske verwendet, um bestimmte Elemente \neines Arrays auszuwählen. Die Maske ist ein Array gleicher Länge wie das Original, \ndas aus den Werten `True` oder `False` besteht. \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Erstellen wir ein Beispiel Array\na = np.array([1, 2, 3, 4, 5, 6])\n\n# Erstellen der Maske\nmaske = a > 3\n\nprint(maske)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[False False False  True  True  True]\n```\n:::\n:::\n\n\nWir erhalten also ein Array mit boolschen Werten. Verwenden wir diese Maske nun\nzum slicen, erhalten wir alle Werte an den Stellen, an denen die Maske den Wert \n`True` besitzt.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Anwenden der Maske\nprint(a[maske])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4 5 6]\n```\n:::\n:::\n\n\nMehrere Masken können mit dem Operator `*` zu einem logischen UND verknüpft werden.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# 2 Masken\ngerade_zahlen = a % 2 == 0\nkleiner_3 = a < 3\nprint(gerade_zahlen, kleiner_3, sep = '\\n')\n\n# logisches UND beider Masken\nprint(a[kleiner_3 * gerade_zahlen])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[False  True False  True False  True]\n[ True  True False False False False]\n[2]\n```\n:::\n:::\n\n\n::: {.callout-warning}\n\nDas Verwenden von booleschen Arrays ist nicht für native Python-Listen möglich.\nHier muss durch die Liste iterriert werden.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5, 6]\nergebnis = [x for x in a if x > 3]\nprint(ergebnis) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4, 5, 6]\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n\n## Zwischenübung: Array-Slicing\n\nWählen Sie die farblich markierten Bereiche aus dem Array \"matrix\" mit den eben \ngelernten Möglichkeiten des Array-Slicing aus.\n\n![](../skript/00-bilder/exercise_slicing.svg){fig-alt=\"Grafische Darstellung der in der folgenden Code-Zelle erstellten Matrix.\"}\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nmatrix = np.array([\n    [2, 11, 18, 47, 33, 48, 9, 31, 8, 41],\n    [55, 1, 8, 3, 91, 56, 17, 54, 23, 12],\n    [19, 99, 56, 72, 6, 13, 34, 16, 77, 56],\n    [37, 75, 67, 5, 46, 98, 57, 19, 14, 7],\n    [4, 57, 32, 78, 56, 12, 43, 61, 3, 88],\n    [96, 16, 92, 18, 50, 90, 35, 15, 36, 97],\n    [75, 4, 38, 53, 1, 79, 56, 73, 45, 56],\n    [15, 76, 11, 93, 87, 8, 2, 58, 86, 94],\n    [51, 14, 60, 57, 74, 42, 59, 71, 88, 52],\n    [49, 6, 43, 39, 17, 18, 95, 6, 44, 75]\n])\n```\n:::\n\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Lösung\n\n* Rot: matrix[1,3]\n* Grün: matrix[4:6,2:6]\n* Pink: matrix[:,7]\n* Orange: matrix[7,:5]\n* Blau: matrix[-1,-1]\n\n:::\n\n:::\n\n",
    "supporting": [
      "array_slicing_files/figure-pdf"
    ],
    "filters": []
  }
}
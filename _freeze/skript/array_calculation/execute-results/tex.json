{
  "hash": "d16bc775bf8100c44ebd4459c0de759b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Rechnen mit Arrays\n\n## Arithmetische Funktionen\n\n\n\nEin großer Vorteil an NumPy ist das Rechnen mit Arrays. Ohne NumPy müsste man \nentweder eine `Schleife` oder aber `List comprehension` benutzen, um mit \nsämtlichen Werten in der Liste zu rechnen. In NumPy fällt diese Unannehmlichkeit \nweg.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 8, 7, 6, 5])\n```\n:::\n\n\nNormale mathematische Operationen, wie die Addition, lassen sich auf zwei Arten \nausdrücken. Entweder über die `np.add()` Funktion oder aber simpel über das `+` \nZeichen.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nnp.add(a,b)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([10, 10, 10, 10, 10])\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\na + b\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([10, 10, 10, 10, 10])\n```\n:::\n:::\n\n\nOhne NumPy würde die Operation folgendermaßen aussehen:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nergebnis = np.ones(5)\nfor i in range(len(a)):\n    ergebnis[i] = a[i] + b[i]\n\nprint(ergebnis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10. 10. 10. 10. 10.]\n```\n:::\n:::\n\n\nFür die anderen Rechenarten existieren auch Funktionen: `np.subtract()`, \n`np.multiply()` und `np.divide()`. \n\nAuch für die anderen höheren Rechenoperationen gibt es ebenfalls Funktionen:\n\n* `np.exp(a)`\n* `np.sqrt(a)`\n* `np.power(a, 3)`\n* `np.sin(a)`\n* `np.cos(a)`\n* `np.tan(a)`\n* `np.log(a)`\n* `a.dot(b)`\n\n::: {.callout-warning}\n\n## Arbeiten mit Winkelfunktionen\n\nWie auch am Taschenrechner birgt das Arbeiten mit den Winkelfunktionen \n(sin, cos, ...) die Fehlerquelle, dass man nicht mit Radian-Werten, sondern mit \nGrad-Werten arbeitet. Die Winkelfunktionen in numpy erwarten jedoch \nRadian-Werte. \n\nFür eine einfache Umrechnung bietet NumPy die Funktionen `np.grad2rad()`und \n`np.rad2grad()`.\n\n:::\n\n## Vergleiche\n\nNumPy-Arrays lassen sich auch miteinander vergleichen. Betrachten wir die \nfolgenden zwei Arrays:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 2, 7, 4, 5])\n```\n:::\n\n\nMöchten wir feststellen, ob diese zwei Arrays identisch sind, können wir \nden `==`-Komparator benutzen. Dieser vergleicht die Arrays elementweise.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([False,  True, False,  True,  True])\n```\n:::\n:::\n\n\nEs ist außerdem möglich Arrays mit den `>`- und `<`-Operatoren zu vergleichen:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\na < b\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([ True, False,  True, False, False])\n```\n:::\n:::\n\n\nMöchte man Arrays mit Gleitkommazahlen vergleichen, ist es oftmals nötig, eine \ngewisse Toleranz zu benutzen, da bei Rechenoperationen minimale Rundungsfehler \nentstehen können. \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nnp.False_\n```\n:::\n:::\n\n\nFür diesen Fall gibt es eine Vergleichsfunktion `np.isclose(a,b,atol)`, wobei \n`atol` für die absolute Toleranz steht. Im folgenden Beispiel wird eine absolute \nToleranz von 0,001 verwendet.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\nprint(np.isclose(a, b, atol=0.001))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\n## Warum ist 0.1 + 0.2 nicht gleich 0.3?\n\nZahlen werden intern als Binärzahlen dargestellt. So wie 1/3 nicht mit einer \nendlichen Anzahl an Ziffern korrekt dargestellt werden kann müssen Zahlen ggf. \ngerundet werden, um im Binärsystem dargestellt zu werden. \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\na = 0.1\nb = 0.2\nprint(a + b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n:::\n\n## Aggregatfunktionen\n\nFür verschiedene Auswertungen benötigen wir Funktionen, wie etwa die Summen \noder die Mittelwert-Funktion. Starten wir mit einem Beispiel Array a:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 8])\n```\n:::\n\n\nDie Summer wird über die Funktion `np.sum()` berechnet.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nnp.sum(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nnp.int64(18)\n```\n:::\n:::\n\n\nNatürlich lassen sich auch der Minimalwert und der Maximalwert eines Arrays \nermitteln. Die beiden Funktionen lauten `np.min()`und `np.max()`. \n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nnp.min(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nnp.int64(1)\n```\n:::\n:::\n\n\nMöchte man nicht das Maximum selbst, sondern die Position des Maximums bestimmen, \nwird statt `np.max` die Funktion `np.argmax`verwendet.\n\nFür statistische Auswertungen werden häufig die Funktion für den Mittelwert \n`np.mean()`, die Funktion für den Median `np.median()`und die Funktion für die \nStandardabweichung `np.std()`verwendet.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nnp.mean(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nnp.float64(3.6)\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nnp.median(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nnp.float64(3.0)\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nnp.std(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nnp.float64(2.4166091947189146)\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Zwischenübung: Arrayinformationen auslesen\n\nGegeben sind zwei eindimensionale Arrays a und b:\n\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) und \nb = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\n1. Erstellen Sie ein neues Array, das die Sinuswerte der addierten Arrays a \nund b enthält.\n2. Berechnen Sie die Summe, den Mittelwert und die Standardabweichung der \nElemente in a.\n3. Finden Sie den größten und den kleinsten Wert in a und b.\n\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\nb = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\n# 1.\nsin_ab = np.sin(a + b)\n\n# 2.\nsum_a = np.sum(a)\nmean_a = np.mean(a)\nstd_a = np.std(a)\n\n# 3.\nmax_a = np.max(a)\nmin_a = np.min(a)\nmax_b = np.max(b)\nmin_b = np.min(b)\n```\n:::\n\n\n:::\n\n:::\n\n",
    "supporting": [
      "array_calculation_files/figure-pdf"
    ],
    "filters": []
  }
}
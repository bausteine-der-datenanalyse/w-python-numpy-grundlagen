{
  "hash": "1525594e855db737bfb5b85dc5477490",
  "result": {
    "engine": "jupyter",
    "markdown": "# Array Manipulation\n\n\n\n## Ändern der Form\n\nDurch verschiedene Funktionen lassen sich die Form und die Einträge der Arrays \nverändern. \n\nEine der wichtigsten Array Operationen ist das Transponieren. Dabei werden \nReihen in Spalten und Spalten in Reihe umgewandelt.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nprint(matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]]\n```\n:::\n:::\n\n\nTransponieren wir dieses Array nun erhalten wir:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(np.transpose(matrix))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 4]\n [2 5]\n [3 6]]\n```\n:::\n:::\n\n\nHaben wir ein nun diese Matrix und wollen daraus einen Vektor erstellen so \nkönnen wir die Funktion `np.flatten()` benutzen:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nvector = matrix.flatten()\nprint(vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6]\n```\n:::\n:::\n\n\nUm wieder eine zweidimensionale Datenstruktur zu erhalten, benutzen wir die \nFunktion `np.reshape(Ziel, Form)`\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(np.reshape(matrix, [3, 2]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2]\n [3 4]\n [5 6]]\n```\n:::\n:::\n\n\nMöchten wir den Inhalt eines bereits bestehenden Arrays erweitern, verkleinern \noder ändern bietet NumPy ebenfalls die passenden Funktionen.\n\nHaben wir ein leeres Array oder wollen wir ein schon volles Array erweitern \nbenutzen wir die Funktion `np.append()`. Dabei hängen wir einen Wert an das \nbereits bestehende Array an.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nneue_liste = np.append(liste, 7)\nprint(neue_liste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6 7]\n```\n:::\n:::\n\n\nGegebenenfalls ist es nötig einen Wert nicht am Ende, sondern an einer beliebigen \nPosition im Array einzufügen. Das passende Werkzeug ist hier die Funktion \n`np.insert(Array, Position, Einschub)`. Im folgenden Beispiel wird an der \ndritten Stelle die Zahl 7 eingesetzt.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nneue_liste = np.insert(liste, 3, 7)\nprint(neue_liste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 7 4 5 6]\n```\n:::\n:::\n\n\nWenn sich neue Elemente einfügen lassen, können natürlich auch Elemente \ngelöscht werden. Hierfür wird die Funktion `np.delete(Array , Position)` \nbenutzt, die ein Array und die Position der zu löschenden Funktion übergeben \nbekommt.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nneue_liste = np.delete(liste, 3)\nprint(neue_liste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 5 6]\n```\n:::\n:::\n\n\nZuletzt wollen wir uns noch die Verbindung zweier Arrays anschauen. Im \nfolgenden Beispiel wird dabei das Array `b` an das Array `a` mithilfe der \nFunktion `np.concatenate((Array a, Array b))`angehängt.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5, 6])\nb = np.array([7, 8, 9, 10])\n\nneue_liste = np.concatenate((a, b))\nprint(neue_liste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 1  2  3  4  5  6  7  8  9 10]\n```\n:::\n:::\n\n\n## Sortieren von Arrays\n\nNumPy bietet auch die Möglichkeit, Arrays zu sortieren. Im folgenden Beispiel \nstarten wir mit einem unsortierten Array. Mit der Funktion `np.sort()` erhalten \nwir ein sortiertes Array.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\nunsortiert = np.array([4, 2, 1, 6, 3, 5])\n\nsortiert = np.sort(unsortiert)\n\nprint(sortiert)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6]\n```\n:::\n:::\n\n\n## Unterlisten mit einzigartigen Werten\n\nArbeitet man mit Daten bei denen zum Beispiel Projekte Personalnummern \nzugeordnet werden hat man Daten mit einer endlichen Anzahl an Personalnummern, \ndie jedoch mehrfach vorkommen können wenn diese an mehr als einem Projekt \ngleichzeitig arbeiten.\n\nMöchte man nun eine Liste die jede Nummer nur einmal enthält, kann die Funtkion \n`np.unique` verwendet werden. \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np\nliste_mit_dopplungen = np.array([4, 1, 1, 6, 3, 4, 7, 3, 3])\n\neinzigartige_werte = np.unique(liste_mit_dopplungen)\n\nprint(einzigartige_werte)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 3 4 6 7]\n```\n:::\n:::\n\n\nSetzt man dann noch die Option `return_counts=True` kann in einer zweiten Variable \ngespeichert werden, wie oft jeder Wert vorkommt.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\nliste_mit_dopplungen = np.array([4, 1, 1, 6, 3, 4, 7, 3, 3])\n\neinzigartige_werte, anzahl = np.unique(liste_mit_dopplungen, return_counts=True)\n\nprint(anzahl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 3 2 1 1]\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Zwischenübung: Arraymanipulation\n\nGegeben ist das folgende zweidimensionale Array matrix:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nmatrix = np.array([\n    [4, 7, 2, 8],\n    [1, 5, 3, 6],\n    [9, 2, 4, 7]\n])\n```\n:::\n\n\n1. Ändern Sie die Form des Arrays matrix in ein eindimensionales Array.\n2. Sortieren Sie das eindimensionale Array in aufsteigender Reihenfolge.\n3. Ändern Sie die Form des sortierten Arrays in ein zweidimensionales Array \nmit 2 Zeilen und 6 Spalten.\n4. Bestimmen Sie die eindeutigen Elemente im ursprünglichen Array matrix und \ngeben Sie diese aus.\n\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nmatrix = np.array([\n    [4, 7, 2, 8],\n    [1, 5, 3, 6],\n    [9, 2, 4, 7]\n])\n\n# 1. Ändern der Form in ein eindimensionales Array\nflat_array = matrix.flatten()\n\n# 2. Sortieren des eindimensionalen Arrays in aufsteigender Reihenfolge\nsorted_array = np.sort(flat_array)\n\n# 3. Ändern der Form des sortierten Arrays in ein 2x6-Array\nreshaped_array = sorted_array.reshape(2, 6)\n\n# 4. Bestimmen der eindeutigen Elemente im ursprünglichen Array\nunique_elements_original = np.unique(matrix)\n```\n:::\n\n\n:::\n\n:::\n\n",
    "supporting": [
      "array_manipulation_files/figure-pdf"
    ],
    "filters": []
  }
}
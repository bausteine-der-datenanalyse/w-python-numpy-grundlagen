{
  "hash": "c89b0e6451d88fa0b9c7108a5ee9df0d",
  "result": {
    "engine": "jupyter",
    "markdown": "# Größe, Struktur und Typ\n\n\n\nWenn man sich nicht mehr sicher ist, welche Struktur oder Form ein Array hat oder \noder diese Größen zum Beispiel für Schleifen nutzen möchte, bietet NumPy \nfolgende Funktionen für das Auslesen dieser Größen an.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n```\n:::\n\n\n`np.shape()` gibt die Längen der einzelnen Dimension in Form einer Liste zurück. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nnp.shape(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n(2, 3)\n```\n:::\n:::\n\n\nDie native Python Funktion `len()` gibt dagegen nur die Länge der ersten \nDimension, also die Anzahl der Elemente in den äußeren Klammern wieder. \nIm obrigen Beispiel würde `len()` also die beiden Listen `[1, 2, 3]` und \n`[4, 5, 6]` sehen.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nlen(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n2\n```\n:::\n:::\n\n\nDie Funktion `np.ndym()`gibt im Gegensatz zu `np.shape()` nur die Anzahl der \nDimensionen zurück. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nnp.ndim(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Die Ausgabe von `np.ndim()` kann mit `np.size()`und einer nativen Python Funktion erreicht werden. Wie?\n\n`np.ndim()` gibt die Länge der Liste von `np.shape()` aus\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nlen(np.shape(matrix))\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2\n```\n:::\n:::\n\n\n:::\n\nMöchte man die Anzahl aller Elemente in einem Array ausgeben kann man die \nFunktion `np.size()` benutzen.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnp.size(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n6\n```\n:::\n:::\n\n\nNumPy Arrays können verschiedene Datentypen beinhalten. Im folgenden haben wir \ndrei verschiedene Arrays mit einem jeweils anderen Datentypen.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ntyp_a = np.array([1, 2, 3, 4, 5])\ntyp_b = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\ntyp_c = np.array([\"Montag\", \"Dienstag\", \"Mittwoch\"])\n```\n:::\n\n\nMit der Methode `np.dtype` können wir den Datentypen von Arrays ausgeben lassen. \nMeist wird dabei der Typ plus eine Zahl ausgegeben, welche die zum Speichern \nbenötigte Bytezahl angibt. Das Array *typ_a* beinhaltet den Datentypen int64, \nalso ganze Zahlen.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprint(typ_a.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nint64\n```\n:::\n:::\n\n\nDas Array *typ_b* beinhaltet den Datentypen float64, wobei float für \nGleitkommazahlen steht.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprint(typ_b.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfloat64\n```\n:::\n:::\n\n\nDas Array *typ_c* beinhaltet den Datentypen U8, wobei das U für Unicode steht. \nHier wird als Unicodetext gespeichert.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(typ_c.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<U8\n```\n:::\n:::\n\n\nIm folgenden finden Sie eine Tabelle mit den typischen Datentypen, die sie \nhäufig antreffen.\n\n| Datentyp              | Numpy Name | Beispiele                  |\n|-----------------------|------------|----------------------------|\n| Wahrheitswert         | `bool`     | [True, False, True]        |\n| Ganze Zahl            | `int`      | [-2, 5, -6, 7, 3]          |\n| positive Ganze Zahlen | `uint`     | [1, 2, 3, 4, 5]            |\n| Kommazahlen           | `float`    | [1.3, 7.4, 3.5, .5.5]      |\n| komplexe zahlen       | `complex`  | [-1 + 9j, 2-77j, 72 + 11j] |\n| Textzeichen           | `U`        | [\"montag\", \"dienstag\"]     |\n\n: Typische Datentypen in NumPy {#tbl-datatypes .striped .hover}\n\n::: {.callout-tip collapse=\"true\"}\n\n## Zwischenübung: Arrayinformationen auslesen\n\nGegeben sei folgende Matrix: \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nmatrix = np.array([[[ 0,  1,  2,  3],\n                 [ 4,  5,  6,  7],\n                 [ 8,  9, 10, 11]],\n\n                [[12, 13, 14, 15],\n                 [16, 17, 18, 19],\n                 [20, 21, 22, 23]],\n\n                [[24, 25, 26, 27],\n                 [28, 29, 30, 31],\n                 [32, 33, 34, 35]]])\n```\n:::\n\n\nBestimmen Sie durch anschauen die Anzahl an Dimensionen und die Länge jeder \nDimension. Von welchem Typ ist der Inhalt dieser Matrix?\n\nÜberprüfen Sie daraufhin Ihre Ergebnisse in dem Sie die passenden NumPy-Funktionen\nanwenden.\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nmatrix = np.array([[[ 0,  1,  2,  3],\n                 [ 4,  5,  6,  7],\n                 [ 8,  9, 10, 11]],\n\n                [[12, 13, 14, 15],\n                 [16, 17, 18, 19],\n                 [20, 21, 22, 23]],\n\n                [[24, 25, 26, 27],\n                 [28, 29, 30, 31],\n                 [32, 33, 34, 35]]])\n\nanzahl_dimensionen = np.ndim(matrix)\n\nlaenge_dimensionen = np.shape(matrix)\n\nprint(matrix.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nint64\n```\n:::\n:::\n\n\n:::\n\n:::\n\n",
    "supporting": [
      "array_info_files/figure-pdf"
    ],
    "filters": []
  }
}